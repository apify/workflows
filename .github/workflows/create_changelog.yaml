name: create release

on:
  workflow_call:
    inputs:
      changelogScopes:
        description: 'Changelog scopes (i.e { "App": ["app", "application"] })'
        required: true
        type: string
      slackChannelId:
        description: Slack Channel ID
        required: false
        type: string
      releaseName:
        description: This value overrides release name got from release branch name
        required: false
        type: string
      releaseNamePrefix:
        description: Prepend prefix to releaseName
        required: false 
        type: string
        default: 'v'
    
    secrets:
      slackToken:
        description: Slack API token
        required: false

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: clone repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: get changelog
        id: changelog
        uses: apify/release-pr-action@v2.3.0
        with: 
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          changelog-scopes: ${{ inputs.changelogScopes }}
          create-pull-request: false
          compare-method: pull_request

      - name: create github release
        uses: actions/github-script@v6
        id: release
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs/promises');

            // Expecting brach to be named release/vX.Y.Z
            const SEMVER_REGEX = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
            const VERSION_PREFIX = '${{ inputs.releaseNamePrefix }}';

            let releaseName;
            let alreadyExists = false;

            const checkSemverAndModify = (version, bump = false) => {
                let cleanVersion;

                if (version.slice(0, VERSION_PREFIX.length) === VERSION_PREFIX) {
                    cleanVersion = version.slice(VERSION_PREFIX.length);
                } else {
                    cleanVersion = version;
                }

                if (!SEMVER_REGEX.test(cleanVersion)) throw new Error(`Version: ${version} does not uphold to semantic versioning standard!`);

                if (bump) {
                    const cleanVersionSplit = cleanVersion.split('.');
                    const minor = cleanVersionSplit[1];
                    if (!minor) throw new Error(`Version: ${version} does not have a minor to bump!`);
                    return `${VERSION_PREFIX}${cleanVersion[0]}.${Number(minor)+1}.${cleanVersion[0]}`;
                }

                return version;
            }

            if ('${{ inputs.releaseName }}') {
                releaseName = '${{ inputs.releaseName }}';
            } else {
                if (process.env.GITHUB_HEAD_REF) {
                    releaseName = checkSemverAndModify(process.env.GITHUB_HEAD_REF.split('/')[1]);
                }
            }

            // If all of the above fails try to read last release and bump it
            if (!releaseName) {
                console.log('Trying to determine release name from last release name..')
                const releases = await github.rest.repos.listReleases({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                });
                if (releases.data.length === 0) {
                    releaseName = `${VERSION_PREFIX}0.0.0`;
                } else {
                    const { name, tag_name: tagName} = releases.data[0];
                    console.log(`Discovered last release name: ${name}`);
                    const tag = await github.rest.git.getRef({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: `tags/${tagName}`,
                    });

                    const tagCommitSha = tag.data.object.sha;

                    // If tag of last release already exists on current commit SHA, then do not create new release
                    if (tagCommitSha === context.sha) {
                        console.log(`Release with tag ${tagName} already exists! Refusing to override!`);
                        return { releaseName: null, alreadyExists: true };
                    }
                    releaseName = checkSemverAndModify(name, true);
                }
            }

            if (!releaseName) {
                throw new Error('Could not get release name from branch name or "releaseName" input!');
            }

            const changelogFileDestination = '${{ steps.changelog.outputs.changelogFileDestination }}';
            let changelog;
            try {
                changelog = await fs.readFile(changelogFileDestination, 'utf-8');
            } catch (error) {
                console.error(`Could not read ${changelogFileDestination} from file-system`);
                throw error;
            }

            console.log(`Publishing new release: ${releaseName}`);
            try {
                await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: releaseName,
                    name: releaseName,
                    target_commitish: '${{ github.base_ref || github.ref_name }}',
                    body: changelog,
                });
            } catch (error) {
                if (error.response.data.errors[0].code === 'already_exists') {
                    console.log(`Release with name ${releaseName} already exists! Refusing to override!`);
                    alreadyExists = true;
                } else {
                    throw error;
                }
            }
            return { releaseName, alreadyExists };

      # This step changes format of changelog from Github to Slack markdown-ish
      # and replaces newline chars with literal \n
      # TODO: should probably be part of apify/release-pr-action
      - name: format changelog for slack api
        if: ${{ fromJSON(steps.release.outputs.result).alreadyExists == false && inputs.slackChannelId != '' }}
        id: format
        run: |
          echo "${{ steps.changelog.outputs.changelog }}" | sed 's/\*\*/\*/g' | sed 's/\* /â€¢ /g' > changelog.txt
          changelog=$(awk '{printf "%s\\n", $0}' changelog.txt)
          echo "changelog=${changelog}" >> $GITHUB_OUTPUT
      
      - name: send changelog to slack
        if: ${{ fromJSON(steps.release.outputs.result).alreadyExists == false && inputs.slackChannelId != '' }}
        uses: slackapi/slack-github-action@v1.23.0
        env:
          SLACK_BOT_TOKEN: ${{ secrets.slackToken }}
        with:
          channel-id: ${{ inputs.slackChannelId }}
          payload: |
            {
              "text": "Changelog",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "_Repository_: *${{ github.repository }}* _Revision_: *${{ fromJSON(steps.release.outputs.result).releaseName }}*\n${{ steps.format.outputs.changelog }}"
                  }
                }
              ]
            }